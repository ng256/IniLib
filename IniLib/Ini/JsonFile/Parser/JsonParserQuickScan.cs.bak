using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Text.RegularExpressions;

[DebuggerDisplay("{Content}")]
public class JsonParserQuickScan
{
    private string _content;
    private StringComparison _comparison;
    private bool _prettyOutput = true;

    private static readonly Regex TokenRegex = new Regex(
        @"(?<value>(?<true>true)|(?<false>false)|(?<null>null)|""(?<string>[^""\\]*(?:\\.[^""\\]*)*)""|(?<number>-?(?:0|[1-9][0-9]*)(?:\.[0-9]+)?(?:[eE][+-]?[0-9]+)?))|(?<value_sep>:)|(?<array_open>\[)|(?<array_sep>,)|(?<array_close>\])|(?<object_open>{)|(?<object_close>})|(?<whitespace>\s)",
        RegexOptions.Compiled);

    public JsonParserQuickScan(string content, StringComparison comparison = StringComparison.InvariantCultureIgnoreCase, bool prettyOutput = true)
    {
        this._content = string.IsNullOrWhiteSpace(content) ? "{}" : content;
        _prettyOutput = prettyOutput;
        this._comparison = comparison;
    }

    public JsonParserQuickScan(StringComparison comparison) : this("{}", comparison)
    {
    }

    public JsonParserQuickScan() : this("{}", StringComparison.Ordinal)
    {
    }

    public StringComparison Comparison
    {
        get => _comparison;
        set => _comparison = value;
    }

    public string Content
    {
        get => _content;
        set => _content = value;
    }

    public string GetValue(string path, string defaultValue)
    {
        try
        {
            var root = ParseJson(Content);
            var keys = path.Split('.');
            var value = GetValueRecursive(root, keys, 0);
            return value?.ToString() ?? defaultValue;
        }
        catch
        {
            return defaultValue;
        }
    }

    public string[] GetValues(string path)
    {
        try
        {
            var root = ParseJson(Content);
            var keys = path.Split('.');
            var value = GetValueRecursive(root, keys, 0);

            if (value is List<object> list)
            {
                var result = new List<string>();
                foreach (var item in list)
                {
                    result.Add(SerializeJson(item));
                }
                return result.ToArray();
            }

            return new string[0];
        }
        catch
        {
            return new string[0];
        }
    }

    public void SetValue(string path, string value)
    {
        try
        {
            var root = ParseJson(Content);
            var keys = path.Split('.');
            SetValueRecursive(root, keys, 0, value);
            Content = SerializeJson(root);
        }
        catch
        {
            // Quietly fail
        }
    }

    public void SetValues(string path, params string[] values)
    {
        try
        {
            var root = ParseJson(Content);
            var keys = path.Split('.');
            SetValuesRecursive(root, keys, 0, values);
            Content = SerializeJson(root);
        }
        catch
        {
            // Quietly fail
        }
    }

    private object GetValueRecursive(object current, string[] keys, int index)
    {
        if (index >= keys.Length) return current;

        if (current is Dictionary<string, object> obj)
        {
            var key = FindKey(obj, keys[index]);
            if (key != null)
            {
                return GetValueRecursive(obj[key], keys, index + 1);
            }
        }

        return null; // Return null if path doesn't exist
    }

    private void SetValueRecursive(object current, string[] keys, int index, string value)
    {
        if (index >= keys.Length) return;

        if (current is Dictionary<string, object> obj)
        {
            var key = FindKey(obj, keys[index]) ?? keys[index];
            if (index == keys.Length - 1)
            {
                obj[key] = ParseJson(value);
            }
            else
            {
                if (!obj.ContainsKey(key) || !(obj[key] is Dictionary<string, object>))
                {
                    obj[key] = new Dictionary<string, object>();
                }
                SetValueRecursive(obj[key], keys, index + 1, value);
            }
        }
    }

    private void SetValuesRecursive(object current, string[] keys, int index, string[] values)
    {
        if (index >= keys.Length) return;

        if (current is Dictionary<string, object> obj)
        {
            var key = FindKey(obj, keys[index]) ?? keys[index];
            if (index == keys.Length - 1)
            {
                var array = new List<object>();
                foreach (var value in values)
                {
                    array.Add(ParseJson(value));
                }
                obj[key] = array;
            }
            else
            {
                if (!obj.ContainsKey(key) || !(obj[key] is Dictionary<string, object>))
                {
                    obj[key] = new Dictionary<string, object>();
                }
                SetValuesRecursive(obj[key], keys, index + 1, values);
            }
        }
    }

    private string FindKey(Dictionary<string, object> obj, string targetKey)
    {
        return obj.Keys.FirstOrDefault(key => string.Equals(key, targetKey, _comparison));
    }

    private object ParseJson(string json)
    {
        var tokens = Tokenize(json);
        return ParseValue(tokens);
    }

    private object ParseValue(Queue<string> tokens)
    {
        if (tokens.Count == 0) return null;

        var token = tokens.Dequeue();

        if (token == "{") return ParseObject(tokens);
        if (token == "[") return ParseArray(tokens);
        if (token.StartsWith("\"") && token.EndsWith("\"")) return token.Trim('"');
        if (token == "true") return true;
        if (token == "false") return false;
        if (token == "null") return null;

        if (double.TryParse(token, out var number)) return number;

        return null;
    }

    private Dictionary<string, object> ParseObject(Queue<string> tokens)
    {
        var obj = new Dictionary<string, object>();

        while (tokens.Count > 0)
        {
            var token = tokens.Dequeue();
            if (token == "}") break;

            if (token.StartsWith("\"") && token.EndsWith("\""))
            {
                var key = token.Trim('"');
                if (tokens.Dequeue() != ":") return obj; // Invalid syntax
                obj[key] = ParseValue(tokens);
            }
        }

        return obj;
    }

    private List<object> ParseArray(Queue<string> tokens)
    {
        var list = new List<object>();

        while (tokens.Count > 0)
        {
            var token = tokens.Peek();
            if (token == "]")
            {
                tokens.Dequeue();
                break;
            }

            list.Add(ParseValue(tokens));

            if (tokens.Peek() == ",") tokens.Dequeue();
        }

        return list;
    }

    private string SerializeJson(object obj, int indentLevel = 0)
    {
        string indent = new string(' ', indentLevel * 2);  // 2 spaces per indent level

        if (obj is Dictionary<string, object> dict)
        {
            var items = new List<string>();
            foreach (var kvp in dict)
            {
                items.Add($"\"{kvp.Key}\": {SerializeJson(kvp.Value, indentLevel + 1)}");
            }
            return _prettyOutput ? $"{{\n{indent}  {string.Join(",\n" + indent + "  ", items)}\n{indent}}}" : $"{{{string.Join(",", items)}}}";
        }

        if (obj is List<object> list)
        {
            var items = new List<string>();
            foreach (var item in list)
            {
                items.Add(SerializeJson(item, indentLevel + 1));
            }
            return _prettyOutput ? $"[\n{indent}  {string.Join(",\n" + indent + "  ", items)}\n{indent}]" : $"[{string.Join(",", items)}]";
        }

        if (obj is string str) return $"\"{str}\"";
        if (obj is bool b) return b ? "true" : "false";
        if (obj is null) return "null";

        return obj.ToString();
    }


    private Queue<string> Tokenize(string input)
    {
        var tokens = new Queue<string>();
        var matches = TokenRegex.Matches(input);
        foreach (Match match in matches)
        {
            if (!string.IsNullOrWhiteSpace(match.Value))
            {
                tokens.Enqueue(match.Value);
            }
        }
        return tokens;
    }

    public override string ToString()
    {
        return Content;
    }
}